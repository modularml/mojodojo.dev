import{_ as t}from"./hero-CbGtQ2Lh.js";import{_ as n,c as a,a as s,d as r,r as i,o as l}from"./app-CGzBYgfx.js";const c={};function p(h,e){const o=i("CommentService");return l(),a("div",null,[e[0]||(e[0]=s('<p><img src="'+t+`" alt="Logo"></p><h1 id="this-week-in-mojo-2023-06-09" tabindex="-1"><a class="header-anchor" href="#this-week-in-mojo-2023-06-09"><span>This Week in Mojo 2023-06-09</span></a></h1><h2 id="mojo-playground-update" tabindex="-1"><a class="header-anchor" href="#mojo-playground-update"><span>Mojo Playground Update</span></a></h2><p><a href="https://docs.modular.com/mojo/changelog.html" target="_blank" rel="noopener noreferrer">Changelog Here</a></p><h3 id="‚≠êÔ∏è-new" tabindex="-1"><a class="header-anchor" href="#‚≠êÔ∏è-new"><span>‚≠êÔ∏è New</span></a></h3><p>Tuple syntax now works on the left-hand side of assignments (in ‚Äúlvalue‚Äù positions), enabling things like (a, b) = (b, a).</p><p>There are several caveats: the element types must exactly match (no implicit conversions), this only work with values of TupleLiteral type (notably, it will not work with PythonObject yet) and parentheses are required for tuple syntax.</p><h3 id="‚ùå-removed" tabindex="-1"><a class="header-anchor" href="#‚ùå-removed"><span>‚ùå Removed</span></a></h3><p>Mojo Playground no longer includes the following Python packages (due to size, compute costs, and environment complications): torch, tensorflow, keras, transformers.</p><h3 id="ü¶ã-changed" tabindex="-1"><a class="header-anchor" href="#ü¶ã-changed"><span>ü¶ã Changed</span></a></h3><p>The data types and scalar names now conform to the naming convention used by numpy. So we use Int32 instead of SI32, similarly using Float32 instead of F32. Closes Issue <a href="https://github.com/modularml/mojo/issues/152" target="_blank" rel="noopener noreferrer">Issue #152</a>.</p><h3 id="üõ†Ô∏è-fixed" tabindex="-1"><a class="header-anchor" href="#üõ†Ô∏è-fixed"><span>üõ†Ô∏è Fixed</span></a></h3><ul><li><a href="https://github.com/modularml/mojo/issues/287" target="_blank" rel="noopener noreferrer">Issue #287</a> - computed lvalues don‚Äôt handle raising functions correctly</li><li><a href="https://github.com/modularml/mojo/issues/318" target="_blank" rel="noopener noreferrer">Issue #318</a>- Large integers are not being printed correctly</li><li><a href="https://github.com/modularml/mojo/issues/326" target="_blank" rel="noopener noreferrer">Issue #326</a> - Float modulo operator is not working as expected</li><li><a href="https://github.com/modularml/mojo/issues/282" target="_blank" rel="noopener noreferrer">Issue #282</a>- Default arguments are not working as expected</li><li><a href="https://github.com/modularml/mojo/issues/271" target="_blank" rel="noopener noreferrer">Issue #271</a>- Confusing error message when converting between function types with different result semantics</li></ul><h2 id="official-content" tabindex="-1"><a class="header-anchor" href="#official-content"><span>Official Content</span></a></h2><ul><li>New Proposal: <a href="https://github.com/modularml/mojo/blob/main/proposals/lifetimes-and-provenance.md" target="_blank" rel="noopener noreferrer">Provenance Tracking and Lifetimes in Mojo</a></li><li>New Proposal: <a href="https://github.com/modularml/mojo/blob/main/proposals/lifetimes-keyword-renaming.md" target="_blank" rel="noopener noreferrer">Keyword Naming</a></li><li>Blog Post: <a href="https://www.modular.com/blog/if-ai-serving-tech-cant-solve-todays-problems-how-do-we-scale-into-the-future" target="_blank" rel="noopener noreferrer">If AI serving tech can‚Äôt solve today‚Äôs problems, how do we scale into the future?</a></li><li>Blog Post: <a href="https://www.modular.com/blog/do-llms-eliminate-the-need-for-programming-languages" target="_blank" rel="noopener noreferrer">Do LLMs eliminate the need for programming languages?</a></li></ul><h2 id="community-content" tabindex="-1"><a class="header-anchor" href="#community-content"><span>Community Content</span></a></h2><ul><li><a href="https://www.thapaliya.com/" target="_blank" rel="noopener noreferrer">Suvash</a> did a blog post on implementing <a href="https://www.thapaliya.com/en/writings/hello-with-a-glider-gun-mojo/" target="_blank" rel="noopener noreferrer">Game of Life in Mojo</a> and video <a href="https://youtu.be/pduYnTpRBLo" target="_blank" rel="noopener noreferrer">introduction to Mojo</a></li></ul><h2 id="mojo-team-answers" tabindex="-1"><a class="header-anchor" href="#mojo-team-answers"><span>Mojo Team Answers</span></a></h2><h3 id="pure-functions" tabindex="-1"><a class="header-anchor" href="#pure-functions"><span>Pure Functions</span></a></h3><p>Pureness is what is known as an &quot;effect&quot; in PL terminology. You can see this in the handling of async and raises in the current mojo implementation: a non-raising function is not allowed to call a raising function directly - it must wrap it in a try block.</p><p>I don&#39;t see a way to provide this sort of mapping from one world to the other for purity, I think we cannot practically implement this, and while pure computation is important, it is actually quite complicated: is reading from memory pure? If no, &quot;purity&quot; is pretty useless. If so, you cannot use purity information for much optimization, because you need to know which memory sets may be read and written by functions anyway.</p><p>Also, in other pure-functional languages like Haskell, you need escape hatches (perform unsafe io) because you want to add printf debugging etc to &quot;pure&quot; functions and compiler enforcement makes that whole thing incredibly difficult.</p><p>Overall I can understand wanting to have this conceptually, but I can&#39;t see how it could work out well in practice. We can come back to this later as the language evolves.</p><p><a href="https://github.com/modularml/mojo/discussions/345#discussioncomment-6136537" target="_blank" rel="noopener noreferrer">2023-06-09 Pure Functions</a></p><h3 id="becoming-a-mojo-champion-mod-on-discord" tabindex="-1"><a class="header-anchor" href="#becoming-a-mojo-champion-mod-on-discord"><span>Becoming a <code>Mojo Champion</code> mod on Discord</span></a></h3><p>We reached out to individuals we identified ourselves this time. In the future as the server scales, if we look to add more, we will probably send out an application form that folks can fill out and we&#39;ll review on a rolling basis.</p><p><a href="https://discord.com/channels/1087530497313357884/1116515673611448352/1116528356603736084" target="_blank" rel="noopener noreferrer">2023-06-09 Discord Andrew</a></p><h3 id="string-to-pythonobject" tabindex="-1"><a class="header-anchor" href="#string-to-pythonobject"><span>String to PythonObject</span></a></h3><p>Right now you can turn a <code>StringRef</code> or a <code>StringLiteral</code> into a <code>PythonObject</code>. To get a <code>PythonObject</code> from a <code>String</code>, you&#39;d need to turn the <code>String</code> into a <code>StringRef</code>. This is available through some underscored methods, but it&#39;s currently unsafe due to some lifetime issues. Let me see if I can add a direct conversion path, though it will take a week to make its way to the playground.</p><p>A direct conversion should be included in the next Playground release.</p><p><a href="https://discord.com/channels/1087530497313357884/1116063443200520334/1116066258664828949" target="_blank" rel="noopener noreferrer">2023-06-08 Discord Alex Kirchhoff</a></p><h3 id="compiler-guidance" tabindex="-1"><a class="header-anchor" href="#compiler-guidance"><span>Compiler Guidance</span></a></h3><p>Mojo already gives a couple warnings that suggest better things to do, such as using <code>let</code> instead of <code>var</code> where possible. That said, the compiler isn&#39;t good at pointing out larger design pattern changes, for this I think we&#39;ll have LLM based tools outside the compiler itself. The UI is much better for explaining things in that context.</p><p><a href="https://github.com/modularml/mojo/discussions/323#discussioncomment-6084627" target="_blank" rel="noopener noreferrer">2023-06-05 GitHub Chris Lattner</a></p><h3 id="compile-time-metaprogramming-relationship-to-mlir" tabindex="-1"><a class="header-anchor" href="#compile-time-metaprogramming-relationship-to-mlir"><span>Compile time metaprogramming relationship to MLIR</span></a></h3><p>Mojo has great support for evaluating fairly arbitrary expressions at compile time with an interpreter that (under the covers) ends up calling an MLIR dialect&#39;s fold operations.</p><p>These then get wrapped up in structs to give a new programmable veneer etc. Check out the Bool workbook example in the documentation for a simple example of doing this with the index dialect.</p><p>Mojo is designed &quot;for&quot; MLIR in this way - MLIR can talk to roughly anything that computes, and it is very important (over time) for Mojo to scale into new forms of computation, whether it be low level things like low-level tensorcore operators, mid-level things like a shape dialect, or high level things like an ML operator graph.</p><p>Right now many folks on the channel are excited about a Python++, but Mojo was designed to work backwards from the &quot;speed of light&quot; of hardware and accelerators. The syntax and applicability to Python is important for community reasons, but not particularly relevant to the accelerator side of Mojo.</p><p><a href="https://discord.com/channels/1087530497313357884/1114406301808726138/1116540613618323517" target="_blank" rel="noopener noreferrer">2023-06-12 Discord Chris Lattner</a></p><h3 id="loose-typing" tabindex="-1"><a class="header-anchor" href="#loose-typing"><span>Loose Typing</span></a></h3><p>This is an evolving part of the language and likely another difference we pull into the <code>fn</code> vs <code>def</code> world, in a <code>def</code> we could default to getting objects for literals, but within a <code>fn</code> you get typed literals. Another potential solution is to have aggressive decay rules in <code>def</code> e.g. <code>True</code> starts out being typed to <code>Bool</code> but we allow decaying to object when an expression doesn&#39;t type check otherwise. We&#39;ll need to experiment with that when we make progress on other more basic things. The major reason to have both <code>def</code> and <code>fn</code> is to have a Python compatible world and a stricter systems programmer world, and have them coexist seamlessly.</p><p><a href="https://discord.com/channels/1087530497313357884/1114818534946648165/1114971056671838350" target="_blank" rel="noopener noreferrer">2023-06-05 Discord Chris Lattner</a></p><h3 id="struct-memory-layout-c-compatibility" tabindex="-1"><a class="header-anchor" href="#struct-memory-layout-c-compatibility"><span>Struct Memory Layout C Compatibility</span></a></h3><p>I agree that an opt-in decorator that specifies layout is the right way to go. By default the compiler should be able to reorder fields to eliminate internal padding so programmers don&#39;t have to worry about this, but people putting bits on a wire or dealing with c compatibility should be able to get that. We will need to properly design this out.</p><p><a href="https://github.com/modularml/mojo/discussions/289#discussioncomment-6080125" target="_blank" rel="noopener noreferrer">2023-06-04 Github Chris Lattner</a></p><h3 id="int-provenance" tabindex="-1"><a class="header-anchor" href="#int-provenance"><span>Int Provenance</span></a></h3><p>Ints and pointers are different things, so no ints don&#39;t carry provenance. This is one of the major things that C/C++ got wrong that has haunted LLVM IR and many other things for a long time. Taking a hard line on this makes everything simpler, but that is only possible when you have a fresh slate like Mojo provides us.</p><p><a href="https://discord.com/channels/1087530497313357884/1098713601386233997/1115452333074153653" target="_blank" rel="noopener noreferrer">2023-06-06 Discord Chris Lattner</a></p><h3 id="float8" tabindex="-1"><a class="header-anchor" href="#float8"><span>Float8</span></a></h3><p>There are so many variants of Float8 representation. We need to think about which ones does Mojo represents and how to expose the variety. For now, we are removing Float8 from the DType list to avoid folks from falling into this trap.</p><p><a href="https://github.com/modularml/mojo/discussions/289#discussioncomment-6080125" target="_blank" rel="noopener noreferrer">2023-06-04 Github Abdul Dakkak</a></p><h3 id="integer-overflow-on-object" tabindex="-1"><a class="header-anchor" href="#integer-overflow-on-object"><span>Integer Overflow on <code>object</code></span></a></h3><p>It needs to eventually provide full Python semantics, so we&#39;ll need <code>object</code> to contain a <code>PythonObject</code> in its variant. We could overflow from inline <code>int</code> to Python object on demand.</p><p><a href="https://github.com/modularml/mojo/issues/328#issuecomment-1579468329" target="_blank" rel="noopener noreferrer">2023-06-04 Github Chris Lattner</a></p><h3 id="boolean-on-simd-types" tabindex="-1"><a class="header-anchor" href="#boolean-on-simd-types"><span>Boolean on SIMD types</span></a></h3><p>The way to do this is by explicitly calling the bool method later:</p><div class="language-mojo" data-highlighter="prismjs" data-ext="mojo" data-title="mojo"><pre class="shiki tokyo-night vp-code" style="background-color:#1a1b26;color:#a9b1d6 language-mojo;"><code><span class="line"><span class="line"><span style="color:#BB9AF7;">struct</span><span style="color:#C0CAF5;"> MyPair</span><span style="color:#9ABDF5;">:</span></span></span>
<span class="line"><span class="line"><span style="color:#9D7CD8;font-style:italic;">    var</span><span style="color:#C0CAF5;"> first</span><span style="color:#89DDFF;">:</span><span style="color:#A9B1D6;"> Float32</span></span></span>
<span class="line"><span class="line"><span style="color:#9D7CD8;font-style:italic;">    var</span><span style="color:#C0CAF5;"> second</span><span style="color:#89DDFF;">:</span><span style="color:#A9B1D6;"> Float32</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#BB9AF7;">    fn</span><span style="color:#0DB9D7;"> __lt__</span><span style="color:#9ABDF5;">(</span><span style="color:#E0AF68;">self</span><span style="color:#89DDFF;">,</span><span style="color:#E0AF68;"> rhs</span><span style="color:#89DDFF;">:</span><span style="color:#A9B1D6;"> MyPair</span><span style="color:#9ABDF5;">)</span><span style="color:#89DDFF;"> -&gt;</span><span style="color:#A9B1D6;"> Bool</span><span style="color:#9ABDF5;">:</span></span></span>
<span class="line"><span class="line"><span style="color:#BB9AF7;">        return</span><span style="color:#89DDFF;"> (</span></span></span>
<span class="line"><span class="line"><span style="color:#F7768E;">            self</span><span style="color:#89DDFF;">.</span><span style="color:#A9B1D6;">first </span><span style="color:#BB9AF7;">&lt;</span><span style="color:#A9B1D6;"> rhs</span><span style="color:#89DDFF;">.</span><span style="color:#A9B1D6;">first</span></span></span>
<span class="line"><span class="line"><span style="color:#BB9AF7;">            or</span><span style="color:#89DDFF;"> (</span><span style="color:#F7768E;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A9B1D6;">first </span><span style="color:#BB9AF7;">==</span><span style="color:#A9B1D6;"> rhs</span><span style="color:#89DDFF;">.</span><span style="color:#A9B1D6;">first </span><span style="color:#BB9AF7;">and</span><span style="color:#F7768E;"> self</span><span style="color:#89DDFF;">.</span><span style="color:#A9B1D6;">second </span><span style="color:#BB9AF7;">&lt;</span><span style="color:#A9B1D6;"> rhs</span><span style="color:#89DDFF;">.</span><span style="color:#A9B1D6;">second</span><span style="color:#89DDFF;">)</span></span></span>
<span class="line"><span class="line"><span style="color:#89DDFF;">        ).</span><span style="color:#0DB9D7;">__bool__</span><span style="color:#9ABDF5;">()</span></span></span></code></pre></div><p>We could add <code>SIMD[DType.bool, 1]</code> as an initializer to the <code>Bool</code> type, but cannot do that currently because <code>Bool</code> is a builtin type while <code>SIMD</code> is not. We need to think about this and have a library-based solution.</p><p><a href="https://github.com/modularml/mojo/issues/335" target="_blank" rel="noopener noreferrer">2023-06-07 Github Abdul Dakkak</a></p><h3 id="string-supporting-utf-8" tabindex="-1"><a class="header-anchor" href="#string-supporting-utf-8"><span><code>String</code> supporting UTF-8</span></a></h3><p>We want to enhance the <code>String</code> type to support UTF-8 encoding before starting work on file system.</p><p><a href="https://github.com/modularml/mojo/issues/306#issuecomment-1579268808" target="_blank" rel="noopener noreferrer">2023-06-07 Github Abdul Dakkak</a></p><h3 id="mutable-and-explicit-types-when-iterating-over-collections" tabindex="-1"><a class="header-anchor" href="#mutable-and-explicit-types-when-iterating-over-collections"><span>Mutable and explicit types when iterating over collections</span></a></h3><p>This was noted as a known <code>sharp edge</code> in the <a href="https://docs.modular.com/mojo/roadmap.html" target="_blank" rel="noopener noreferrer">roadmap &amp; sharp edges</a> document. The behaviour here is definitely subject to change, maybe syntax like <code>for var i in range(3)</code> but I don&#39;t have a strong opinion.</p><p><a href="https://github.com/modularml/mojo/issues/331#issuecomment-1579122472" target="_blank" rel="noopener noreferrer">2023-06-07 Github Jeff Niu</a></p><h3 id="local-toolchain-release" tabindex="-1"><a class="header-anchor" href="#local-toolchain-release"><span>Local Toolchain Release</span></a></h3><p>We are working on this, and expect to ship it in <code>O(few months)</code>! Please <a href="https://www.modular.com/newsletter" target="_blank" rel="noopener noreferrer">sign up for our newsletter</a> to track progress, thanks!</p><p><a href="https://github.com/modularml/mojo/discussions/327#discussioncomment-6095594" target="_blank" rel="noopener noreferrer">2023-06-06 Github Chris Lattner</a></p>`,69)),r(o)])}const u=n(c,[["render",p],["__file","2023-06-09.html.vue"]]),g=JSON.parse('{"path":"/this-week-in-mojo/2023-06-09.html","title":"This Week in Mojo 2023-06-09","lang":"en-US","frontmatter":{"title":"This Week in Mojo 2023-06-09","date":"2023-06-09T00:00:00.000Z","author":"Mojo Dojo","author_site":"https://mojodojo.dev","author_image":"https://mojodojo.dev/hero.png","feed":true,"head":[["meta",{"name":"twitter:card","content":"summary"}],["meta",{"name":"twitter:site","content":"@mojodojodev"}],["meta",{"name":"twitter:title","content":"This Week in Mojo"}],["meta",{"name":"twitter:description","content":"This week in Mojo with language updates, community content, and everything else related to Mojo"}],["meta",{"name":"twitter:image","content":"https://mojodojo.dev/hero.png"}]]},"headers":[{"level":2,"title":"Mojo Playground Update","slug":"mojo-playground-update","link":"#mojo-playground-update","children":[{"level":3,"title":"‚≠êÔ∏è New","slug":"‚≠êÔ∏è-new","link":"#‚≠êÔ∏è-new","children":[]},{"level":3,"title":"‚ùå Removed","slug":"‚ùå-removed","link":"#‚ùå-removed","children":[]},{"level":3,"title":"ü¶ã Changed","slug":"ü¶ã-changed","link":"#ü¶ã-changed","children":[]},{"level":3,"title":"üõ†Ô∏è Fixed","slug":"üõ†Ô∏è-fixed","link":"#üõ†Ô∏è-fixed","children":[]}]},{"level":2,"title":"Official Content","slug":"official-content","link":"#official-content","children":[]},{"level":2,"title":"Community Content","slug":"community-content","link":"#community-content","children":[]},{"level":2,"title":"Mojo Team Answers","slug":"mojo-team-answers","link":"#mojo-team-answers","children":[{"level":3,"title":"Pure Functions","slug":"pure-functions","link":"#pure-functions","children":[]},{"level":3,"title":"Becoming a Mojo Champion mod on Discord","slug":"becoming-a-mojo-champion-mod-on-discord","link":"#becoming-a-mojo-champion-mod-on-discord","children":[]},{"level":3,"title":"String to PythonObject","slug":"string-to-pythonobject","link":"#string-to-pythonobject","children":[]},{"level":3,"title":"Compiler Guidance","slug":"compiler-guidance","link":"#compiler-guidance","children":[]},{"level":3,"title":"Compile time metaprogramming relationship to MLIR","slug":"compile-time-metaprogramming-relationship-to-mlir","link":"#compile-time-metaprogramming-relationship-to-mlir","children":[]},{"level":3,"title":"Loose Typing","slug":"loose-typing","link":"#loose-typing","children":[]},{"level":3,"title":"Struct Memory Layout C Compatibility","slug":"struct-memory-layout-c-compatibility","link":"#struct-memory-layout-c-compatibility","children":[]},{"level":3,"title":"Int Provenance","slug":"int-provenance","link":"#int-provenance","children":[]},{"level":3,"title":"Float8","slug":"float8","link":"#float8","children":[]},{"level":3,"title":"Integer Overflow on object","slug":"integer-overflow-on-object","link":"#integer-overflow-on-object","children":[]},{"level":3,"title":"Boolean on SIMD types","slug":"boolean-on-simd-types","link":"#boolean-on-simd-types","children":[]},{"level":3,"title":"String supporting UTF-8","slug":"string-supporting-utf-8","link":"#string-supporting-utf-8","children":[]},{"level":3,"title":"Mutable and explicit types when iterating over collections","slug":"mutable-and-explicit-types-when-iterating-over-collections","link":"#mutable-and-explicit-types-when-iterating-over-collections","children":[]},{"level":3,"title":"Local Toolchain Release","slug":"local-toolchain-release","link":"#local-toolchain-release","children":[]}]}],"git":{"contributors":[{"name":"Mojo Dojo","username":"Mojo Dojo","email":"mojodojodev@gmail.com","commits":1,"url":"https://github.com/Mojo Dojo"},{"name":"Jack Clayton","username":"Jack Clayton","email":"jackos@me.com","commits":1,"url":"https://github.com/Jack Clayton"}]},"filePathRelative":"this-week-in-mojo/2023-06-09.md"}');export{u as comp,g as data};
